# lengthprefixed

[![GoDoc](https://godoc.org/github.com/dpirotte/lengthprefixed?status.svg)](https://godoc.org/github.com/dpirotte/lengthprefixed)
[![Go Report
Card](https://goreportcard.com/badge/github.com/dpirotte/go-lengthprefixed)](https://goreportcard.com/report/github.com/dpirotte/go-lengthprefixed)
[![Build
Status](https://travis-ci.org/dpirotte/go-lengthprefixed.svg?branch=master)](https://travis-ci.org/dpirotte/go-lengthprefixed)

lengthprefixed implements a Reader and Writer for reading, and writing, streams
of irregularly sized "chunks" of bytes.

This is useful for efficiently streaming, or storing, large quantities of
serialized data structures together when they are not self-delimiting, e.g.
protocol buffer messages.

The lengthprefixed format adds 12-bytes of overhead to user-provided data chunks:
a 4-byte (`uint32`) integer describing the length of a user-provided chunk, and
then an 8-byte (`uint64`) checksum generated by the [xxhash
algorithm](https://cyan4973.github.io/xxHash/).

## Chunk Structure

Each chunk contains three parts: length (4 bytes), chunk data (`length` bytes),
and checksum (8 bytes).

```
0        4                N         N+8
+--------+================+----------+
| length |   chunk data   | checksum |
+--------+================+----------+
```

The lengthprefixed API only requires that the user interact with "chunk data". The
length and checksum components are hidden from the user.

## Usage

```
package main

import (
  "bytes"
  "fmt"

  "github.com/dpirotte/lengthprefixed"
)

func main() {
  var buf bytes.Buffer
  w := lengthprefixed.NewWriter(&buf)

  w.Write([]byte("This string would more likely be a protobuf message."))

  r := lengthprefixed.NewReader(&buf)
  b, err := r.ReadFrame()
  if err != nil {
    panic(err)
  }

  fmt.Println(string(b))
}

```
